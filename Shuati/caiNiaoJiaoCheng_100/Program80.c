/*
题目：海滩上有一堆桃子，五只猴子来分。第一只猴子把这堆桃子平均分为五份，多了一个，这只 猴子把多的一个扔入海中，拿走了一份。第二只猴子把剩下的桃子又平均分成五份，又多了 一个，它同样把多的一个扔入海中，拿走了一份，第三、第四、第五只猴子都是这样做的， 问海滩上原来最少有多少个桃子？

问题分析
假设第五只猴子拿到了a个桃子，那么在第五只猴子拿之前，共有5a+1个桃子。
假设第四只猴子拿到了b个桃子，那么在第四只猴子拿到桃子后，还剩4b个桃子。
则，4 b = 5 a + 1 , b = ( 5 a + 1 ) / 4。
假设第三只猴子拿到了c个桃子，那么在第三只猴子拿到桃子后，还剩4c个桃子。
则，4 c = 5 b + 1 , c = ( 5 b + 1 ) / 4。
即前一天猴子拿到的桃子数可以通过后面一天猴子的桃子数推出来，由此可得解题思路：

第五天海滩上的桃子总数m一定可以整除4（否则第四天的桃子数量不是整数），从第五天开始，前一天的桃子总数都是后一天桃子总数的5倍加1。
*/

#include <stdio.h>

int main(void)
{
    int m, i, j, count;            // j代表第五天的桃子数，m暂存j的值，当前j不符合条件时再从m开始遍历
    for (j = 4; j < 10000; j += 4) // j+=4，循环判断第五天的桃子数量应该是多少
    {
        m = j;
        for (i = 0; i < 5; i++)
        {                            // 循环求前四天的桃子数
            count = (j / 4) * 5 + 1; // count为某一天的桃子总数
            if (count % 4 != 0)
                break; // 如果中间结果不能整除4，说明j的值即第五天的桃子数不合适，直接跳出循环
            j = count; // i的for循环判断，按照count = (j / 4) * 5 + 1这个公式依次求出第四天第三天第二天第一天的桃子数
        }
        if (i == 4)                                // 如果i的for循环跑满5次，即i==4，说明j的值（第五天的桃子数）是合适的，可以根据j的值依次求出前四天
                                                   // 的桃子数。而且此时count为第一天的桃子数
            printf("total peaches = %d\n", count); // 打印出第一天的桃子数
        else
            j = m;
    }
    return 0;
}
